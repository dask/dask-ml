

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; dask-ml 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/style.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/explore.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/nbsphinx.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="dask_ml.model_selection.train_test_split" href="generated/dask_ml.model_selection.train_test_split.html" />
    <link rel="prev" title="Tensorflow" href="../tensorflow.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  

<nav id="explore-links">
  <a href="https://dask.pydata.org/">
    <img class="caption" src="../_static/images/dask-horizontal-white.svg"/>
  </a>

  <ul>
    <li>
      <a>Get Started</a>
      <ul>
        <li><a href="https://dask.pydata.org/en/latest/install.html"> Install </a></li>
        <li><a href="https://mybinder.org/v2/gh/dask/dask-examples/master?urlpath=lab"> Examples </a></li>
        <li><a href="https://github.com/dask/dask-tutorial"> Tutorial </a></li>
        <li><a href="https://dask.pydata.org/en/latest/why.html"> Why Dask? </a></li>
        <li><a href="https://dask-stories.readthedocs.io/en/latest"> Use Cases </a></li>
        <li><a href="https://www.youtube.com/watch?v=RA_2qdipVng&list=PLRtz5iA93T4PQvWuoMnIyEIz1fXiJ5Pri"> Talks </a></li>
      </ul>
    </li>

    <li>
      <a href="">Algorithms</a>
      <ul>
        <li><a href="https://dask.pydata.org/en/latest/array.html">Arrays</a></li>
        <li><a href="https://dask.pydata.org/en/latest/dataframe.html">Dataframes</a></li>
        <li><a href="https://dask.pydata.org/en/latest/bag.html">Bags</a></li>
        <li><a href="https://dask.pydata.org/en/latest/delayed.html">Delayed (custom)</a></li>
        <li><a href="https://dask.pydata.org/en/latest/futures.html">Futures (real-time)</a></li>
        <li><a href="http://ml.dask.org">Machine Learning</a></li>
        <li><a href="https://xarray.pydata.org/en/latest/">XArray</a></li>
      </ul>
    </li>

    <li>
      <a href="https://dask.pydata.org/en/latest/setup.html">Deploy</a>
      <ul>
        <li><a href="https://dask-yarn.readthedocs.io/en/latest/"> Hadoop / Yarn </a></li>
        <li><a href="https://dask.pydata.org/en/latest/setup/kubernetes-helm.html"> Helm </a></li>
        <li><a href="https://dask.pydata.org/en/latest/setup/hpc.html"> HPC </a></li>
        <li><a href="https://dask-kubernetes.readthedocs.io/en/latest/"> Kubernetes </a></li>
        <li><a href="https://dask.pydata.org/en/latest/setup/single-machine.html"> Local </a></li>
      </ul>
    </li>

    <li>
      <a>Community</a>
      <ul>
        <li><a href="http://dask.pydata.org/en/latest/support.html">Ask for Help</a></li>
        <li><a href="https://github.com/dask">Github</a></li>
        <li><a href="https://stackoverflow.com/questions/tagged/dask">Stack Overflow</a></li>
        <li><a href="https://twitter.com/dask_dev">Twitter</a></li>
      </ul>
    </li>
  </ul>

</nav>


  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> dask-ml
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
</ul>
<p class="caption"><span class="caption-text">Use</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preprocessing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cross_validation.html">Cross Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hyper-parameter-search.html">Hyper Parameter Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compose.html">Pipelines and Composite Estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glm.html">Generalized Linear Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joblib.html">Joblib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meta-estimators.html">Parallel Meta-estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../incremental.html">Incremental Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../clustering.html">Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xgboost.html">XGBoost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tensorflow.html">Tensorflow</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.model_selection"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>: Model Selection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.train_test_split.html">dask_ml.model_selection.train_test_split</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.ShuffleSplit.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.ShuffleSplit</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.KFold.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.KFold</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.GridSearchCV.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.GridSearchCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.RandomizedSearchCV.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.RandomizedSearchCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.IncrementalSearch.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.IncrementalSearch</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.linear_model"><code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code>: Generalized Linear Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.linear_model.LinearRegression.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code>.LinearRegression</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.linear_model.LogisticRegression.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code>.LogisticRegression</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.linear_model.PoissonRegression.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code>.PoissonRegression</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dask-ml-wrappers-meta-estimators"><code class="docutils literal notranslate"><span class="pre">dask_ml.wrappers</span></code>: Meta-Estimators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.wrappers.ParallelPostFit.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.wrappers</span></code>.ParallelPostFit</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.wrappers.Incremental.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.wrappers</span></code>.Incremental</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.cluster"><code class="docutils literal notranslate"><span class="pre">dask_ml.cluster</span></code>: Clustering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.cluster.KMeans.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.cluster</span></code>.KMeans</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.cluster.SpectralClustering.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.cluster</span></code>.SpectralClustering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.decomposition"><code class="docutils literal notranslate"><span class="pre">dask_ml.decomposition</span></code>: Matrix Decomposition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.decomposition.PCA.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.decomposition</span></code>.PCA</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.decomposition.TruncatedSVD.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.decomposition</span></code>.TruncatedSVD</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.preprocessing"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>: Preprocessing Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.StandardScaler</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.RobustScaler</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.MinMaxScaler</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.QuantileTransformer</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.StandardScaler</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.Categorizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.DummyEncoder</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.OrdinalEncoder</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.LabelEncoder</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dask-ml-compose-composite-estimators"><code class="docutils literal notranslate"><span class="pre">dask_ml.compose</span></code>: Composite Estimators</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dask-ml-impute-imputing-missing-data"><code class="docutils literal notranslate"><span class="pre">dask_ml.impute</span></code>: Imputing Missing Data</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dask-ml-metrics-metrics"><code class="docutils literal notranslate"><span class="pre">dask_ml.metrics</span></code>: Metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#regression-metrics">Regression Metrics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.mean_absolute_error.html">dask_ml.metrics.mean_absolute_error</a></li>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.mean_squared_error.html">dask_ml.metrics.mean_squared_error</a></li>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.r2_score.html">dask_ml.metrics.r2_score</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classification-metrics">Classification Metrics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.accuracy_score.html">dask_ml.metrics.accuracy_score</a></li>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.log_loss.html">dask_ml.metrics.log_loss</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.tensorflow"><code class="docutils literal notranslate"><span class="pre">dask_ml.tensorflow</span></code>: Tensorflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.tensorflow.start_tensorflow.html">dask_ml.tensorflow.start_tensorflow</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.xgboost"><code class="docutils literal notranslate"><span class="pre">dask_ml.xgboost</span></code>: XGBoost</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.xgboost.XGBClassifier.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.xgboost</span></code>.XGBClassifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.xgboost.XGBRegressor.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.xgboost</span></code>.XGBRegressor</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.xgboost.train.html">dask_ml.xgboost.train</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.xgboost.predict.html">dask_ml.xgboost.predict</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Develop</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../roadmap.html">Dask-ML Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">dask-ml</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/modules/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-reference">
<span id="api"></span><h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<p>This page lists all of the estimators and top-level functions in <code class="docutils literal notranslate"><span class="pre">dask_ml</span></code>.
Unless otherwise noted, the estimators implemented in <code class="docutils literal notranslate"><span class="pre">dask-ml</span></code> are
appropriate for parallel and distributed training.</p>
<div class="section" id="module-dask_ml.model_selection">
<span id="dask-ml-model-selection-model-selection"></span><h2><a class="reference internal" href="#module-dask_ml.model_selection" title="dask_ml.model_selection"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code></a>: Model Selection<a class="headerlink" href="#module-dask_ml.model_selection" title="Permalink to this headline">¶</a></h2>
<p>Utilities for hyperparameter optimization.</p>
<p>These estimators will operate in parallel. Their scalability depends
on the underlying estimators being used.</p>
<p>Dask-ML has a few cross validation utilities.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.model_selection.train_test_split.html#dask_ml.model_selection.train_test_split" title="dask_ml.model_selection.train_test_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.train_test_split</span></code></a>(*arrays,&nbsp;…)</td>
<td>Split arrays into random train and test matricies.</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="generated/dask_ml.model_selection.train_test_split.html#dask_ml.model_selection.train_test_split" title="dask_ml.model_selection.train_test_split"><code class="xref py py-func docutils literal notranslate"><span class="pre">model_selection.train_test_split()</span></code></a> is a simple helper that
uses <a class="reference internal" href="generated/dask_ml.model_selection.ShuffleSplit.html#dask_ml.model_selection.ShuffleSplit" title="dask_ml.model_selection.ShuffleSplit"><code class="xref py py-class docutils literal notranslate"><span class="pre">model_selection.ShuffleSplit</span></code></a> internally.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.model_selection.ShuffleSplit.html#dask_ml.model_selection.ShuffleSplit" title="dask_ml.model_selection.ShuffleSplit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.ShuffleSplit</span></code></a>([n_splits,&nbsp;…])</td>
<td>Random permutation cross-validator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.model_selection.KFold.html#dask_ml.model_selection.KFold" title="dask_ml.model_selection.KFold"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.KFold</span></code></a>([n_splits,&nbsp;shuffle,&nbsp;…])</td>
<td>K-Folds cross-validator</td>
</tr>
</tbody>
</table>
<p>Dask-ML provides drop-in replacements for grid and randomized search.
These are appropriate for datasets where the CV splits fit in memory.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.model_selection.GridSearchCV.html#dask_ml.model_selection.GridSearchCV" title="dask_ml.model_selection.GridSearchCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.GridSearchCV</span></code></a>(estimator,&nbsp;…)</td>
<td>Exhaustive search over specified parameter values for an estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.model_selection.RandomizedSearchCV.html#dask_ml.model_selection.RandomizedSearchCV" title="dask_ml.model_selection.RandomizedSearchCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.RandomizedSearchCV</span></code></a>(…[,&nbsp;…])</td>
<td>Randomized search on hyper parameters.</td>
</tr>
</tbody>
</table>
<p>For hyperparameter optimization on larger-than-memory datasets, Dask-ML
provides the follwoing:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.model_selection.IncrementalSearch.html#dask_ml.model_selection.IncrementalSearch" title="dask_ml.model_selection.IncrementalSearch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.IncrementalSearch</span></code></a>(estimator,&nbsp;…)</td>
<td>Incrementally search for hyper-parameters on models that support partial_fit</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.linear_model">
<span id="dask-ml-linear-model-generalized-linear-models"></span><h2><a class="reference internal" href="#module-dask_ml.linear_model" title="dask_ml.linear_model"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code></a>: Generalized Linear Models<a class="headerlink" href="#module-dask_ml.linear_model" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code> module implements linear models for
classification and regression.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.linear_model.LinearRegression.html#dask_ml.linear_model.LinearRegression" title="dask_ml.linear_model.LinearRegression"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_model.LinearRegression</span></code></a>([penalty,&nbsp;…])</td>
<td>Esimator for linear_regression.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.linear_model.LogisticRegression.html#dask_ml.linear_model.LogisticRegression" title="dask_ml.linear_model.LogisticRegression"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_model.LogisticRegression</span></code></a>([penalty,&nbsp;…])</td>
<td>Esimator for logistic_regression.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.linear_model.PoissonRegression.html#dask_ml.linear_model.PoissonRegression" title="dask_ml.linear_model.PoissonRegression"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_model.PoissonRegression</span></code></a>([penalty,&nbsp;…])</td>
<td>Esimator for poisson_regression.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dask-ml-wrappers-meta-estimators">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.wrappers</span></code>: Meta-Estimators<a class="headerlink" href="#dask-ml-wrappers-meta-estimators" title="Permalink to this headline">¶</a></h2>
<p>dask-ml provides some meta-estimators that help use regular
estimators that follow the scikit-learn API.
These meta-estimators make the underlying estimator work well
with Dask Arrays or DataFrames.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.wrappers.ParallelPostFit.html#dask_ml.wrappers.ParallelPostFit" title="dask_ml.wrappers.ParallelPostFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrappers.ParallelPostFit</span></code></a>([estimator,&nbsp;scoring])</td>
<td>Meta-estimator for parallel predict and transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.wrappers.Incremental.html#dask_ml.wrappers.Incremental" title="dask_ml.wrappers.Incremental"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrappers.Incremental</span></code></a>([estimator,&nbsp;scoring,&nbsp;…])</td>
<td>Metaestimator for feeding Dask Arrays to an estimator blockwise.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.cluster">
<span id="dask-ml-cluster-clustering"></span><h2><a class="reference internal" href="#module-dask_ml.cluster" title="dask_ml.cluster"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.cluster</span></code></a>: Clustering<a class="headerlink" href="#module-dask_ml.cluster" title="Permalink to this headline">¶</a></h2>
<p>Unsupervised Clustering Algorithms</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.cluster.KMeans.html#dask_ml.cluster.KMeans" title="dask_ml.cluster.KMeans"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cluster.KMeans</span></code></a>([n_clusters,&nbsp;init,&nbsp;…])</td>
<td>Scalable KMeans for clustering</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.cluster.SpectralClustering.html#dask_ml.cluster.SpectralClustering" title="dask_ml.cluster.SpectralClustering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cluster.SpectralClustering</span></code></a>([n_clusters,&nbsp;…])</td>
<td>Apply parallel Spectral Clustering</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.decomposition">
<span id="dask-ml-decomposition-matrix-decomposition"></span><h2><a class="reference internal" href="#module-dask_ml.decomposition" title="dask_ml.decomposition"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.decomposition</span></code></a>: Matrix Decomposition<a class="headerlink" href="#module-dask_ml.decomposition" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.decomposition.PCA.html#dask_ml.decomposition.PCA" title="dask_ml.decomposition.PCA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomposition.PCA</span></code></a>([n_components,&nbsp;copy,&nbsp;…])</td>
<td>Principal component analysis (PCA)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.decomposition.TruncatedSVD.html#dask_ml.decomposition.TruncatedSVD" title="dask_ml.decomposition.TruncatedSVD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomposition.TruncatedSVD</span></code></a>([n_components,&nbsp;…])</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.preprocessing">
<span id="dask-ml-preprocessing-preprocessing-data"></span><h2><a class="reference internal" href="#module-dask_ml.preprocessing" title="dask_ml.preprocessing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code></a>: Preprocessing Data<a class="headerlink" href="#module-dask_ml.preprocessing" title="Permalink to this headline">¶</a></h2>
<p>Utilties for Preprocessing data.</p>
<dl class="class">
<dt id="dask_ml.preprocessing.StandardScaler">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">StandardScaler</code><span class="sig-paren">(</span><em>copy=True</em>, <em>with_mean=True</em>, <em>with_std=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardize features by removing the mean and scaling to unit variance</p>
<p>Centering and scaling happen independently on each feature by computing
the relevant statistics on the samples in the training set. Mean and
standard deviation are then stored to be used on later data using the
<cite>transform</cite> method.</p>
<p>Standardization of a dataset is a common requirement for many
machine learning estimators: they might behave badly if the
individual feature do not more or less look like standard normally
distributed data (e.g. Gaussian with 0 mean and unit variance).</p>
<p>For instance many elements used in the objective function of
a learning algorithm (such as the RBF kernel of Support Vector
Machines or the L1 and L2 regularizers of linear models) assume that
all features are centered around 0 and have variance in the same
order. If a feature has a variance that is orders of magnitude larger
that others, it might dominate the objective function and make the
estimator unable to learn from other features correctly as expected.</p>
<p>This scaler can also be applied to sparse CSR or CSC matrices by passing
<cite>with_mean=False</cite> to avoid breaking the sparsity structure of the data.</p>
<p>Read more in the <a class="reference external" href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-scaler" title="(in scikit-learn v0.19.2)"><span class="xref std std-ref">User Guide</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional, default True</span></dt>
<dd><p class="first last">If False, try to avoid a copy and do inplace scaling instead.
This is not guaranteed to always work inplace; e.g. if the data is
not a NumPy array or scipy.sparse CSR matrix, a copy may still be
returned.</p>
</dd>
<dt><strong>with_mean</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, True by default</span></dt>
<dd><p class="first last">If True, center the data before scaling.
This does not work (and will raise an exception) when attempted on
sparse matrices, because centering them entails building a dense
matrix which in common use cases is likely to be too large to fit in
memory.</p>
</dd>
<dt><strong>with_std</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, True by default</span></dt>
<dd><p class="first last">If True, scale the data to unit variance (or equivalently,
unit standard deviation).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scale_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_features,)</span></dt>
<dd><p class="first">Per feature relative scaling of the data.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>scale_</em></p>
</div>
</dd>
<dt><strong>mean_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of floats with shape [n_features]</span></dt>
<dd><p class="first last">The mean value for each feature in the training set.</p>
</dd>
<dt><strong>var_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of floats with shape [n_features]</span></dt>
<dd><p class="first last">The variance for each feature in the training set. Used to compute
<cite>scale_</cite></p>
</dd>
<dt><strong>n_samples_seen_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of samples processed by the estimator. Will be reset on
new calls to fit, but increments across <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> calls.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt>
<dd>Equivalent function without the estimator API.</dd>
<dt><a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA" title="(in scikit-learn v0.19.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.decomposition.PCA</span></code></a></dt>
<dd>Further removes the linear correlation across features with ‘whiten=True’.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <a class="reference external" href="http://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" title="(in scikit-learn v0.19.2)"><span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">StandardScaler</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">StandardScaler(copy=True, with_mean=True, with_std=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">mean_</span><span class="p">)</span>
<span class="go">[ 0.5  0.5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">[[-1. -1.]</span>
<span class="go"> [-1. -1.]</span>
<span class="go"> [ 1.  1.]</span>
<span class="go"> [ 1.  1.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span>
<span class="go">[[ 3.  3.]]</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.fit" title="dask_ml.preprocessing.StandardScaler.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Compute the mean and std to be used for later scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.fit_transform" title="dask_ml.preprocessing.StandardScaler.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.get_params" title="dask_ml.preprocessing.StandardScaler.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.inverse_transform" title="dask_ml.preprocessing.StandardScaler.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X[,&nbsp;copy])</td>
<td>Scale back the data to the original representation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.partial_fit" title="dask_ml.preprocessing.StandardScaler.partial_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_fit</span></code></a>(X[,&nbsp;y])</td>
<td>Online computation of mean and std on X for later scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.set_params" title="dask_ml.preprocessing.StandardScaler.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.transform" title="dask_ml.preprocessing.StandardScaler.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y,&nbsp;copy])</td>
<td>Perform standardization by centering and scaling</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean and std to be used for later scaling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix}, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Passthrough for <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> compatibility.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Training set.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features_new]</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping of string to any</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X</em>, <em>copy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale back the data to the original representation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data used to scale along the features axis.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (default: None)</span></dt>
<dd><p class="first last">Copy the input X or not.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_tr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.partial_fit">
<code class="descname">partial_fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.partial_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Online computation of mean and std on X for later scaling.
All of X is processed as a single batch. This is intended for cases
when <cite>fit</cite> is not feasible due to very large number of <cite>n_samples</cite>
or because X is read from a continuous stream.</p>
<p>The algorithm for incremental mean and std is given in Equation 1.5a,b
in Chan, Tony F., Gene H. Golub, and Randall J. LeVeque. “Algorithms
for computing the sample variance: Analysis and recommendations.”
The American Statistician 37.3 (1983): 242-247:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix}, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Passthrough for <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> compatibility.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>copy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform standardization by centering and scaling</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data used to scale along the features axis.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(ignored)</span></dt>
<dd><div class="first last deprecated">
<p><span class="versionmodified">Deprecated since version 0.19: </span>This parameter will be removed in 0.21.</p>
</div>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (default: None)</span></dt>
<dd><p class="first last">Copy the input X or not.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.MinMaxScaler">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">MinMaxScaler</code><span class="sig-paren">(</span><em>feature_range=(0</em>, <em>1)</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms features by scaling each feature to a given range.</p>
<p>This estimator scales and translates each feature individually such
that it is in the given range on the training set, i.e. between
zero and one.</p>
<p>The transformation is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">X_std</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span>
</pre></div>
</div>
<p>where min, max = feature_range.</p>
<p>This transformation is often used as an alternative to zero mean,
unit variance scaling.</p>
<p>Read more in the <a class="reference external" href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-scaler" title="(in scikit-learn v0.19.2)"><span class="xref std std-ref">User Guide</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>feature_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple (min, max), default=(0, 1)</span></dt>
<dd><p class="first last">Desired range of transformed data.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional, default True</span></dt>
<dd><p class="first last">Set to False to perform inplace row normalization and avoid a
copy (if the input is already a numpy array).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>min_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_features,)</span></dt>
<dd><p class="first last">Per feature adjustment for minimum.</p>
</dd>
<dt><strong>scale_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_features,)</span></dt>
<dd><p class="first">Per feature relative scaling of the data.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>scale_</em> attribute.</p>
</div>
</dd>
<dt><strong>data_min_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_features,)</span></dt>
<dd><p class="first">Per feature minimum seen in the data</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>data_min_</em></p>
</div>
</dd>
<dt><strong>data_max_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_features,)</span></dt>
<dd><p class="first">Per feature maximum seen in the data</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>data_max_</em></p>
</div>
</dd>
<dt><strong>data_range_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_features,)</span></dt>
<dd><p class="first">Per feature range <code class="docutils literal notranslate"><span class="pre">(data_max_</span> <span class="pre">-</span> <span class="pre">data_min_)</span></code> seen in the data</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>data_range_</em></p>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">minmax_scale</span></code></dt>
<dd>Equivalent function without the estimator API.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <a class="reference external" href="http://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" title="(in scikit-learn v0.19.2)"><span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">MinMaxScaler</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">MinMaxScaler(copy=True, feature_range=(0, 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">data_max_</span><span class="p">)</span>
<span class="go">[  1.  18.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">[[ 0.    0.  ]</span>
<span class="go"> [ 0.25  0.25]</span>
<span class="go"> [ 0.5   0.5 ]</span>
<span class="go"> [ 1.    1.  ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span>
<span class="go">[[ 1.5  0. ]]</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.fit" title="dask_ml.preprocessing.MinMaxScaler.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Compute the minimum and maximum to be used for later scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.fit_transform" title="dask_ml.preprocessing.MinMaxScaler.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.get_params" title="dask_ml.preprocessing.MinMaxScaler.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.inverse_transform" title="dask_ml.preprocessing.MinMaxScaler.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X[,&nbsp;y,&nbsp;copy])</td>
<td>Undo the scaling of X according to feature_range.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.partial_fit" title="dask_ml.preprocessing.MinMaxScaler.partial_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_fit</span></code></a>(X[,&nbsp;y])</td>
<td>Online computation of min and max on X for later scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.set_params" title="dask_ml.preprocessing.MinMaxScaler.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.transform" title="dask_ml.preprocessing.MinMaxScaler.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y,&nbsp;copy])</td>
<td>Scaling features of X according to feature_range.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum and maximum to be used for later scaling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data used to compute the per-feature minimum and maximum
used for later scaling along the features axis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Training set.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features_new]</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping of string to any</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>copy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo the scaling of X according to feature_range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Input data that will be transformed. It cannot be sparse.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.partial_fit">
<code class="descname">partial_fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.partial_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Online computation of min and max on X for later scaling.
All of X is processed as a single batch. This is intended for cases
when <cite>fit</cite> is not feasible due to very large number of <cite>n_samples</cite>
or because X is read from a continuous stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Passthrough for <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> compatibility.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>copy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scaling features of X according to feature_range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Input data that will be transformed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.RobustScaler">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">RobustScaler</code><span class="sig-paren">(</span><em>with_centering=True</em>, <em>with_scaling=True</em>, <em>quantile_range=(25.0</em>, <em>75.0)</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale features using statistics that are robust to outliers.</p>
<p>This Scaler removes the median and scales the data according to
the quantile range (defaults to IQR: Interquartile Range).
The IQR is the range between the 1st quartile (25th quantile)
and the 3rd quartile (75th quantile).</p>
<p>Centering and scaling happen independently on each feature (or each
sample, depending on the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument) by computing the relevant
statistics on the samples in the training set. Median and  interquartile
range are then stored to be used on later data using the <code class="docutils literal notranslate"><span class="pre">transform</span></code>
method.</p>
<p>Standardization of a dataset is a common requirement for many
machine learning estimators. Typically this is done by removing the mean
and scaling to unit variance. However, outliers can often influence the
sample mean / variance in a negative way. In such cases, the median and
the interquartile range often give better results.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.17.</span></p>
</div>
<p>Read more in the <a class="reference external" href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-scaler" title="(in scikit-learn v0.19.2)"><span class="xref std std-ref">User Guide</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>with_centering</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, True by default</span></dt>
<dd><p class="first last">If True, center the data before scaling.
This will cause <code class="docutils literal notranslate"><span class="pre">transform</span></code> to raise an exception when attempted on
sparse matrices, because centering them entails building a dense
matrix which in common use cases is likely to be too large to fit in
memory.</p>
</dd>
<dt><strong>with_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, True by default</span></dt>
<dd><p class="first last">If True, scale the data to interquartile range.</p>
</dd>
<dt><strong>quantile_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple (q_min, q_max), 0.0 &lt; q_min &lt; q_max &lt; 100.0</span></dt>
<dd><p class="first">Default: (25.0, 75.0) = (1st quantile, 3rd quantile) = IQR
Quantile range used to calculate <code class="docutils literal notranslate"><span class="pre">scale_</span></code>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.18.</span></p>
</div>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional, default is True</span></dt>
<dd><p class="first last">If False, try to avoid a copy and do inplace scaling instead.
This is not guaranteed to always work inplace; e.g. if the data is
not a NumPy array or scipy.sparse CSR matrix, a copy may still be
returned.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>center_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of floats</span></dt>
<dd><p class="first last">The median value for each feature in the training set.</p>
</dd>
<dt><strong>scale_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of floats</span></dt>
<dd><p class="first">The (scaled) interquartile range for each feature in the training set.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>scale_</em> attribute.</p>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">robust_scale</span></code></dt>
<dd>Equivalent function without the estimator API.</dd>
<dt><a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA" title="(in scikit-learn v0.19.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.decomposition.PCA</span></code></a></dt>
<dd>Further removes the linear correlation across features with ‘whiten=True’.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <a class="reference external" href="http://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" title="(in scikit-learn v0.19.2)"><span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span></a>.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Median_(statistics">https://en.wikipedia.org/wiki/Median_(statistics</a>)
<a class="reference external" href="https://en.wikipedia.org/wiki/Interquartile_range">https://en.wikipedia.org/wiki/Interquartile_range</a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.fit" title="dask_ml.preprocessing.RobustScaler.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Compute the median and quantiles to be used for scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.fit_transform" title="dask_ml.preprocessing.RobustScaler.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.get_params" title="dask_ml.preprocessing.RobustScaler.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.inverse_transform" title="dask_ml.preprocessing.RobustScaler.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X)</td>
<td>Scale back the data to the original representation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.set_params" title="dask_ml.preprocessing.RobustScaler.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.transform" title="dask_ml.preprocessing.RobustScaler.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X)</td>
<td>Center and scale the data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median and quantiles to be used for scaling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data used to compute the median and quantiles
used for later scaling along the features axis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Training set.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features_new]</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping of string to any</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale back the data to the original representation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><p class="first last">The data used to scale along the specified axis.</p>
</dd>
<dt><strong>This implementation was copied and modified from Scikit-Learn.</strong></dt>
<dd></dd>
<dt><strong>See License information here:</strong></dt>
<dd></dd>
<dt><strong>https://github.com/scikit-learn/scikit-learn/blob/master/README.rst</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Center and scale the data.</p>
<p>Can be called on sparse input, provided that <code class="docutils literal notranslate"><span class="pre">RobustScaler</span></code> has been
fitted to dense input and <code class="docutils literal notranslate"><span class="pre">with_centering=False</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix}</span></dt>
<dd><p class="first last">The data used to scale along the specified axis.</p>
</dd>
<dt><strong>This implementation was copied and modified from Scikit-Learn.</strong></dt>
<dd></dd>
<dt><strong>See License information here:</strong></dt>
<dd></dd>
<dt><strong>https://github.com/scikit-learn/scikit-learn/blob/master/README.rst</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.QuantileTransformer">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">QuantileTransformer</code><span class="sig-paren">(</span><em>n_quantiles=1000</em>, <em>output_distribution='uniform'</em>, <em>ignore_implicit_zeros=False</em>, <em>subsample=100000</em>, <em>random_state=None</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms features using quantile information.</p>
<p>This implementation differs from the scikit-learn implementation
by using approximate quantiles. The scikit-learn docstring follows.</p>
<p>This method transforms the features to follow a uniform or a normal
distribution. Therefore, for a given feature, this transformation tends
to spread out the most frequent values. It also reduces the impact of
(marginal) outliers: this is therefore a robust preprocessing scheme.</p>
<p>The transformation is applied on each feature independently.
The cumulative density function of a feature is used to project the
original values. Features values of new/unseen data that fall below
or above the fitted range will be mapped to the bounds of the output
distribution. Note that this transform is non-linear. It may distort linear
correlations between variables measured at the same scale but renders
variables measured at different scales more directly comparable.</p>
<p>Read more in the <a class="reference external" href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-transformer" title="(in scikit-learn v0.19.2)"><span class="xref std std-ref">User Guide</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n_quantiles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (default=1000)</span></dt>
<dd><p class="first last">Number of quantiles to be computed. It corresponds to the number
of landmarks used to discretize the cumulative density function.</p>
</dd>
<dt><strong>output_distribution</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (default=’uniform’)</span></dt>
<dd><p class="first last">Marginal distribution for the transformed data. The choices are
‘uniform’ (default) or ‘normal’.</p>
</dd>
<dt><strong>ignore_implicit_zeros</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (default=False)</span></dt>
<dd><p class="first last">Only applies to sparse matrices. If True, the sparse entries of the
matrix are discarded to compute the quantile statistics. If False,
these entries are treated as zeros.</p>
</dd>
<dt><strong>subsample</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (default=1e5)</span></dt>
<dd><p class="first last">Maximum number of samples used to estimate the quantiles for
computational efficiency. Note that the subsampling procedure may
differ for value-identical sparse and dense matrices.</p>
</dd>
<dt><strong>random_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, RandomState instance or None, optional (default=None)</span></dt>
<dd><p class="first last">If int, random_state is the seed used by the random number generator;
If RandomState instance, random_state is the random number generator;
If None, the random number generator is the RandomState instance used
by np.random. Note that this is used by subsampling and smoothing
noise.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional, (default=True)</span></dt>
<dd><p class="first last">Set to False to perform inplace transformation and avoid a copy (if the
input is already a numpy array).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>quantiles_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_quantiles, n_features)</span></dt>
<dd><p class="first last">The values corresponding the quantiles of reference.</p>
</dd>
<dt><strong>references_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape(n_quantiles, )</span></dt>
<dd><p class="first last">Quantiles of references.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile_transform</span></code></dt>
<dd>Equivalent function without the estimator API.</dd>
<dt><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler" title="dask_ml.preprocessing.StandardScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StandardScaler</span></code></a></dt>
<dd>perform standardization that is faster, but less robust to outliers.</dd>
<dt><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler" title="dask_ml.preprocessing.RobustScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RobustScaler</span></code></a></dt>
<dd>perform robust standardization that removes the influence of outliers but does not put outliers and inliers on the same scale.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <a class="reference external" href="http://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" title="(in scikit-learn v0.19.2)"><span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">QuantileTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qt</span> <span class="o">=</span> <span class="n">QuantileTransformer</span><span class="p">(</span><span class="n">n_quantiles</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qt</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> 
<span class="go">array([...])</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.fit" title="dask_ml.preprocessing.QuantileTransformer.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Compute the quantiles used for transforming.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.fit_transform" title="dask_ml.preprocessing.QuantileTransformer.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.get_params" title="dask_ml.preprocessing.QuantileTransformer.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.inverse_transform" title="dask_ml.preprocessing.QuantileTransformer.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X)</td>
<td>Back-projection to the original space.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.set_params" title="dask_ml.preprocessing.QuantileTransformer.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.transform" title="dask_ml.preprocessing.QuantileTransformer.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X)</td>
<td>Feature-wise transformation of the data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the quantiles used for transforming.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or sparse matrix, shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to scale along the features axis. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csc_matrix</span></code>. Additionally, the sparse matrix needs to be
nonnegative if <cite>ignore_implicit_zeros</cite> is False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Training set.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features_new]</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping of string to any</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Back-projection to the original space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or sparse matrix, shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to scale along the features axis. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csc_matrix</span></code>. Additionally, the sparse matrix needs to be
nonnegative if <cite>ignore_implicit_zeros</cite> is False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Xt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or sparse matrix, shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The projected data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Feature-wise transformation of the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or sparse matrix, shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to scale along the features axis. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csc_matrix</span></code>. Additionally, the sparse matrix needs to be
nonnegative if <cite>ignore_implicit_zeros</cite> is False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Xt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or sparse matrix, shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The projected data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.Categorizer">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">Categorizer</code><span class="sig-paren">(</span><em>categories=None</em>, <em>columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform columns of a DataFrame to categorical dtype.</p>
<p>This is a useful pre-processing step for dummy, one-hot, or
categorical encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>categories</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping, optional</span></dt>
<dd><p class="first last">A dictionary mapping column name to instances of
<code class="docutils literal notranslate"><span class="pre">pandas.api.types.CategoricalDtype</span></code>. Alternatively, a
mapping of column name to <code class="docutils literal notranslate"><span class="pre">(categories,</span> <span class="pre">ordered)</span></code> tuples.</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">A sequence of column names to limit the categorization to.
This argument is ignored when <code class="docutils literal notranslate"><span class="pre">categories</span></code> is specified.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Index</span></dt>
<dd><p class="first last">The columns that were categorized. Useful when <code class="docutils literal notranslate"><span class="pre">categories</span></code> is None,
and we detect the categorical and object columns</p>
</dd>
<dt><strong>categories_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary mapping column names to dtypes. For pandas&gt;=0.21.0, the
values are instances of <code class="docutils literal notranslate"><span class="pre">pandas.api.types.CategoricalDtype</span></code>. For
older pandas, the values are tuples of <code class="docutils literal notranslate"><span class="pre">(categories,</span> <span class="pre">ordered)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This transformer only applies to <code class="docutils literal notranslate"><span class="pre">dask.DataFrame</span></code> and
<code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>. By default, all object-type columns are converted to
categoricals. The set of categories will be the values present in the
column and the categoricals will be unordered. Pass <code class="docutils literal notranslate"><span class="pre">dtypes</span></code> to control
this behavior.</p>
<p>All other columns are included in the transformed output untouched.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">dask.DataFrame</span></code>, any unknown categoricals will become known.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span> <span class="o">=</span> <span class="n">Categorizer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">dtypes</span>
<span class="go">A       int64</span>
<span class="go">B    category</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">{&#39;B&#39;: CategoricalDtype(categories=[&#39;a&#39;, &#39;b&#39;], ordered=False)}</span>
</pre></div>
</div>
<p>Using CategoricalDtypes for specifying the categories:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="k">import</span> <span class="n">CategoricalDtype</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span> <span class="o">=</span> <span class="n">Categorizer</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">CategoricalDtype</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">CategoricalDtype(categories=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], ordered=False)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.fit" title="dask_ml.preprocessing.Categorizer.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Find the categorical columns.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.fit_transform" title="dask_ml.preprocessing.Categorizer.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.get_params" title="dask_ml.preprocessing.Categorizer.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.set_params" title="dask_ml.preprocessing.Categorizer.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.transform" title="dask_ml.preprocessing.Categorizer.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y])</td>
<td>Transform the columns in <code class="docutils literal notranslate"><span class="pre">X</span></code> according to <code class="docutils literal notranslate"><span class="pre">self.categories_</span></code>.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the categorical columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Training set.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features_new]</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping of string to any</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the columns in <code class="docutils literal notranslate"><span class="pre">X</span></code> according to <code class="docutils literal notranslate"><span class="pre">self.categories_</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_trn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.DataFrame</span></dt>
<dd><p class="first last">Same type as the input. The columns in <code class="docutils literal notranslate"><span class="pre">self.categories_</span></code> will
be converted to categorical dtype.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.DummyEncoder">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">DummyEncoder</code><span class="sig-paren">(</span><em>columns=None</em>, <em>drop_first=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy (one-hot) encode categorical columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">The columns to dummy encode. Must be categorical dtype.
Dummy encodes all categorical dtype columns by default.</p>
</dd>
<dt><strong>drop_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">Whether to drop the first category in each column.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The columns in the training data before dummy encoding</p>
</dd>
<dt><strong>transformed_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The columns in the training data after dummy encoding</p>
</dd>
<dt><strong>categorical_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The categorical columns in the training data</p>
</dd>
<dt><strong>noncategorical_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The rest of the columns in the training data</p>
</dd>
<dt><strong>categorical_blocks_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Mapping from column names to slice objects. The slices
represent the positions in the transformed array that the
categorical column ends up at</p>
</dd>
<dt><strong>dtypes_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">Dictionary mapping column name to either</p>
<ul class="last simple">
<li>instances of CategoricalDtype (pandas &gt;= 0.21.0)</li>
<li>tuples of (categories, ordered)</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This transformer only applies to dask and pandas DataFrames. For dask
DataFrames, all of your categoricals should be known.</p>
<p>The inverse transformation can be used on a dataframe or array.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                     <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">de</span> <span class="o">=</span> <span class="n">DummyEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span> <span class="o">=</span> <span class="n">de</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span>
<span class="go">A  B_a  B_b</span>
<span class="go">0  1    1    0</span>
<span class="go">1  2    1    0</span>
<span class="go">2  3    1    0</span>
<span class="go">3  4    0    1</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">columns_</span>
<span class="go">Index([&#39;A&#39;, &#39;B&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">non_categorical_columns_</span>
<span class="go">Index([&#39;A&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">categorical_columns_</span>
<span class="go">Index([&#39;B&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">dtypes_</span>
<span class="go">{&#39;B&#39;: CategoricalDtype(categories=[&#39;a&#39;, &#39;b&#39;], ordered=False)}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">categorical_blocks_</span>
<span class="go">{&#39;B&#39;: slice(1, 3, None)}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Dask DataFrame Structure:</span>
<span class="go">                A    B_a    B_b</span>
<span class="go">npartitions=2</span>
<span class="go">0              int64  uint8  uint8</span>
<span class="go">2                ...    ...    ...</span>
<span class="go">3                ...    ...    ...</span>
<span class="go">Dask Name: get_dummies, 4 tasks</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.fit" title="dask_ml.preprocessing.DummyEncoder.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Determine the categorical columns to be dummy encoded.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.fit_transform" title="dask_ml.preprocessing.DummyEncoder.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.get_params" title="dask_ml.preprocessing.DummyEncoder.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.inverse_transform" title="dask_ml.preprocessing.DummyEncoder.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X)</td>
<td>Inverse dummy-encode the columns in <cite>X</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.set_params" title="dask_ml.preprocessing.DummyEncoder.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.transform" title="dask_ml.preprocessing.DummyEncoder.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y])</td>
<td>Dummy encode the categorical columns in X</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the categorical columns to be dummy encoded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.dataframe.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Training set.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features_new]</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping of string to any</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse dummy-encode the columns in <cite>X</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or dataframe</span></dt>
<dd><p class="first last">Either the NumPy, dask, or pandas version</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">Dask array or dataframe will return a Dask DataFrame.
Numpy array or pandas dataframe will return a pandas DataFrame</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy encode the categorical columns in X</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pd.DataFrame or dd.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transformed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pd.DataFrame or dd.DataFrame</span></dt>
<dd><p class="first last">Same type as the input</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.OrdinalEncoder">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">OrdinalEncoder</code><span class="sig-paren">(</span><em>columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordinal (integer) encode categorical columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">The columns to encode. Must be categorical dtype.
Encodes all categorical dtype columns by default.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The columns in the training data before/after encoding</p>
</dd>
<dt><strong>categorical_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The categorical columns in the training data</p>
</dd>
<dt><strong>noncategorical_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The rest of the columns in the training data</p>
</dd>
<dt><strong>dtypes_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">Dictionary mapping column name to either</p>
<ul class="last simple">
<li>instances of CategoricalDtype (pandas &gt;= 0.21.0)</li>
<li>tuples of (categories, ordered)</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This transformer only applies to dask and pandas DataFrames. For dask
DataFrames, all of your categoricals should be known.</p>
<p>The inverse transformation can be used on a dataframe or array.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                     <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span>
<span class="go">   A  B</span>
<span class="go">0  1  0</span>
<span class="go">1  2  0</span>
<span class="go">2  3  0</span>
<span class="go">3  4  1</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">columns_</span>
<span class="go">Index([&#39;A&#39;, &#39;B&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">non_categorical_columns_</span>
<span class="go">Index([&#39;A&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">categorical_columns_</span>
<span class="go">Index([&#39;B&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">dtypes_</span>
<span class="go">{&#39;B&#39;: CategoricalDtype(categories=[&#39;a&#39;, &#39;b&#39;], ordered=False)}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Dask DataFrame Structure:</span>
<span class="go">                   A     B</span>
<span class="go">npartitions=2</span>
<span class="go">0              int64  int8</span>
<span class="go">2                ...   ...</span>
<span class="go">3                ...   ...</span>
<span class="go">Dask Name: assign, 8 tasks</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.fit" title="dask_ml.preprocessing.OrdinalEncoder.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Determine the categorical columns to be encoded.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.fit_transform" title="dask_ml.preprocessing.OrdinalEncoder.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.get_params" title="dask_ml.preprocessing.OrdinalEncoder.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.inverse_transform" title="dask_ml.preprocessing.OrdinalEncoder.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X)</td>
<td>Inverse ordinal-encode the columns in <cite>X</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.set_params" title="dask_ml.preprocessing.OrdinalEncoder.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.transform" title="dask_ml.preprocessing.OrdinalEncoder.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y])</td>
<td>Ordinal encode the categorical columns in X</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the categorical columns to be encoded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.dataframe.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Training set.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples, n_features_new]</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping of string to any</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse ordinal-encode the columns in <cite>X</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or dataframe</span></dt>
<dd><p class="first last">Either the NumPy, dask, or pandas version</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">Dask array or dataframe will return a Dask DataFrame.
Numpy array or pandas dataframe will return a pandas DataFrame</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordinal encode the categorical columns in X</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pd.DataFrame or dd.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transformed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pd.DataFrame or dd.DataFrame</span></dt>
<dd><p class="first last">Same type as the input</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.LabelEncoder">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">LabelEncoder</code><span class="sig-paren">(</span><em>use_categorical=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode labels with value between 0 and n_classes-1.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This differs from the scikit-learn version for Categorical data.
When passed a categorical <cite>y</cite>, this implementation will use the
categorical information for the label encoding and transformation.
You will receive different answers when</p>
<ol class="arabic simple">
<li>Your categories are not monotonically increasing</li>
<li>You have unobserved categories</li>
</ol>
<p class="last">Specify <code class="docutils literal notranslate"><span class="pre">use_categorical=False</span></code> to recover the scikit-learn behavior.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>use_categorical</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">Whether to use the categorical dtype information when <cite>y</cite> is a
dask or pandas Series with a categorical dtype.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>classes_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of shape (n_class,)</span></dt>
<dd><p class="first last">Holds the label for each class.</p>
</dd>
<dt><strong>dtype_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Optional CategoricalDtype</span></dt>
<dd><p class="first last">For Categorical <cite>y</cite>, the dtype is stored here.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p><cite>LabelEncoder</cite> can be used to normalize labels.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask_ml</span> <span class="k">import</span> <span class="n">preprocessing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">LabelEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">LabelEncoder()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">classes_</span>
<span class="go">array([1, 2, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span> 
<span class="go">array([0, 0, 1, 2]...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([1, 1, 2, 6])</span>
</pre></div>
</div>
<p>It can also be used to transform non-numerical labels (as long as they are
hashable and comparable) to numerical labels.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">le</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">LabelEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="s2">&quot;paris&quot;</span><span class="p">,</span> <span class="s2">&quot;paris&quot;</span><span class="p">,</span> <span class="s2">&quot;tokyo&quot;</span><span class="p">,</span> <span class="s2">&quot;amsterdam&quot;</span><span class="p">])</span>
<span class="go">LabelEncoder()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">le</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span>
<span class="go">[&#39;amsterdam&#39;, &#39;paris&#39;, &#39;tokyo&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="s2">&quot;tokyo&quot;</span><span class="p">,</span> <span class="s2">&quot;tokyo&quot;</span><span class="p">,</span> <span class="s2">&quot;paris&quot;</span><span class="p">])</span> 
<span class="go">array([2, 2, 1]...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">le</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[&#39;tokyo&#39;, &#39;tokyo&#39;, &#39;paris&#39;]</span>
</pre></div>
</div>
<p>When using Dask, we strongly recommend using a Categorical dask Series if
possible. This avoids a (potentially expensive) scan of the values and
enables a faster <cite>transform</cite> algorithm.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;category&#39;</span><span class="p">),</span>
<span class="gp">... </span>                      <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">dask.array&lt;values, shape=(nan,), dtype=int8, chunksize=(nan,)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 0, 1], dtype=int8)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.fit" title="dask_ml.preprocessing.LabelEncoder.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(y)</td>
<td>Fit label encoder</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.fit_transform" title="dask_ml.preprocessing.LabelEncoder.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(y)</td>
<td>Fit label encoder and return encoded labels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.get_params" title="dask_ml.preprocessing.LabelEncoder.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.inverse_transform" title="dask_ml.preprocessing.LabelEncoder.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(y)</td>
<td>Transform labels back to original encoding.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.set_params" title="dask_ml.preprocessing.LabelEncoder.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.transform" title="dask_ml.preprocessing.LabelEncoder.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(y)</td>
<td>Transform labels to normalized encoding.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit label encoder</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,)</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">returns an instance of self.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit label encoder and return encoded labels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape [n_samples]</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping of string to any</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform labels back to original encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of shape [n_samples]</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform labels to normalized encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape [n_samples]</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape [n_samples]</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler" title="dask_ml.preprocessing.StandardScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.StandardScaler</span></code></a>([copy,&nbsp;…])</td>
<td>Standardize features by removing the mean and scaling to unit variance</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler" title="dask_ml.preprocessing.RobustScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.RobustScaler</span></code></a>([with_centering,&nbsp;…])</td>
<td>Scale features using statistics that are robust to outliers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler" title="dask_ml.preprocessing.MinMaxScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.MinMaxScaler</span></code></a>([feature_range,&nbsp;copy])</td>
<td>Transforms features by scaling each feature to a given range.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer" title="dask_ml.preprocessing.QuantileTransformer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.QuantileTransformer</span></code></a>([…])</td>
<td>Transforms features using quantile information.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler" title="dask_ml.preprocessing.StandardScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.StandardScaler</span></code></a>([copy,&nbsp;…])</td>
<td>Standardize features by removing the mean and scaling to unit variance</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer" title="dask_ml.preprocessing.Categorizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.Categorizer</span></code></a>([categories,&nbsp;columns])</td>
<td>Transform columns of a DataFrame to categorical dtype.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder" title="dask_ml.preprocessing.DummyEncoder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.DummyEncoder</span></code></a>([columns,&nbsp;drop_first])</td>
<td>Dummy (one-hot) encode categorical columns.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder" title="dask_ml.preprocessing.OrdinalEncoder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.OrdinalEncoder</span></code></a>([columns])</td>
<td>Ordinal (integer) encode categorical columns.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder" title="dask_ml.preprocessing.LabelEncoder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.LabelEncoder</span></code></a>([use_categorical])</td>
<td>Encode labels with value between 0 and n_classes-1.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dask-ml-compose-composite-estimators">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.compose</span></code>: Composite Estimators<a class="headerlink" href="#dask-ml-compose-composite-estimators" title="Permalink to this headline">¶</a></h2>
<p>Meta-estimators for building composite models with transformers.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose.ColumnTransformer</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose.make_column_transformer</span></code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dask-ml-impute-imputing-missing-data">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.impute</span></code>: Imputing Missing Data<a class="headerlink" href="#dask-ml-impute-imputing-missing-data" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.impute.SimpleImputer</span></code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dask-ml-metrics-metrics">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.metrics</span></code>: Metrics<a class="headerlink" href="#dask-ml-metrics-metrics" title="Permalink to this headline">¶</a></h2>
<p>Score functions, performance metrics, and pairwise distance computations.</p>
<div class="section" id="regression-metrics">
<h3>Regression Metrics<a class="headerlink" href="#regression-metrics" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.metrics.mean_absolute_error.html#dask_ml.metrics.mean_absolute_error" title="dask_ml.metrics.mean_absolute_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.mean_absolute_error</span></code></a>(y_true,&nbsp;y_pred)</td>
<td>Mean squared error regression loss</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.metrics.mean_squared_error.html#dask_ml.metrics.mean_squared_error" title="dask_ml.metrics.mean_squared_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.mean_squared_error</span></code></a>(y_true,&nbsp;y_pred[,&nbsp;…])</td>
<td>Mean squared error regression loss</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.metrics.r2_score.html#dask_ml.metrics.r2_score" title="dask_ml.metrics.r2_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.r2_score</span></code></a>(y_true,&nbsp;y_pred[,&nbsp;…])</td>
<td>R^2 (coefficient of determination) regression score function.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="classification-metrics">
<h3>Classification Metrics<a class="headerlink" href="#classification-metrics" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.metrics.accuracy_score.html#dask_ml.metrics.accuracy_score" title="dask_ml.metrics.accuracy_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.accuracy_score</span></code></a>(y_true,&nbsp;y_pred[,&nbsp;…])</td>
<td>Accuracy classification score.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.metrics.log_loss.html#dask_ml.metrics.log_loss" title="dask_ml.metrics.log_loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.log_loss</span></code></a>(y_true,&nbsp;y_pred[,&nbsp;eps,&nbsp;…])</td>
<td>Log loss, aka logistic loss or cross-entropy loss.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="module-dask_ml.tensorflow">
<span id="dask-ml-tensorflow-tensorflow"></span><h2><a class="reference internal" href="#module-dask_ml.tensorflow" title="dask_ml.tensorflow"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.tensorflow</span></code></a>: Tensorflow<a class="headerlink" href="#module-dask_ml.tensorflow" title="Permalink to this headline">¶</a></h2>
<p>Interoperate with a <a class="reference external" href="https://www.tensorflow.org/">Tensorflow</a> cluster.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.tensorflow.start_tensorflow.html#dask_ml.tensorflow.start_tensorflow" title="dask_ml.tensorflow.start_tensorflow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start_tensorflow</span></code></a>(client,&nbsp;**kwargs)</td>
<td>Start Tensorflow on Dask Cluster</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.xgboost">
<span id="dask-ml-xgboost-xgboost"></span><h2><a class="reference internal" href="#module-dask_ml.xgboost" title="dask_ml.xgboost"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.xgboost</span></code></a>: XGBoost<a class="headerlink" href="#module-dask_ml.xgboost" title="Permalink to this headline">¶</a></h2>
<p>Train an XGBoost model on dask arrays or dataframes.</p>
<p>This may be used for training an XGBoost model on a cluster. XGBoost
will be setup in distributed mode alongside your existing
<code class="docutils literal notranslate"><span class="pre">dask.distributed</span></code> cluster.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.xgboost.XGBClassifier.html#dask_ml.xgboost.XGBClassifier" title="dask_ml.xgboost.XGBClassifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">XGBClassifier</span></code></a>([max_depth,&nbsp;learning_rate,&nbsp;…])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.xgboost.XGBRegressor.html#dask_ml.xgboost.XGBRegressor" title="dask_ml.xgboost.XGBRegressor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">XGBRegressor</span></code></a>([max_depth,&nbsp;learning_rate,&nbsp;…])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.xgboost.train.html#dask_ml.xgboost.train" title="dask_ml.xgboost.train"><code class="xref py py-obj docutils literal notranslate"><span class="pre">train</span></code></a>(client,&nbsp;params,&nbsp;data,&nbsp;labels[,&nbsp;…])</td>
<td>Train an XGBoost model on a Dask Cluster</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.xgboost.predict.html#dask_ml.xgboost.predict" title="dask_ml.xgboost.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(client,&nbsp;model,&nbsp;data)</td>
<td>Distributed prediction with XGBoost</td>
</tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="generated/dask_ml.model_selection.train_test_split.html" class="btn btn-neutral float-right" title="dask_ml.model_selection.train_test_split" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../tensorflow.html" class="btn btn-neutral" title="Tensorflow" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Dask developers.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>